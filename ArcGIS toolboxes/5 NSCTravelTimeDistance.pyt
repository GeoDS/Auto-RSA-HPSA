# -*- coding: utf-8 -*-import arcpyarcpy.env.workspace = "D:\\Box Sync\\Spring 2021\\DHS Project\\DHS_safegraph\\scratch.gdb"arcpy.env.overwriteOutput = Trueclass Toolbox(object):    def __init__(self):        """Define the toolbox (the name of the toolbox is the name of the        .pyt file)."""        self.label = "Toolbox"        self.alias = "toolbox"        # List of tool classes associated with this toolbox        self.tools = [Tool]class Tool(object):    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "NSC scoring"        self.description = "Calculate the NSC score"        self.canRunInBackground = False    def getParameterInfo(self):        """Define parameter definitions"""       #first parameter        param0 = arcpy.Parameter(        displayName="Population Centroid",        name="pop_cen",        datatype="GPFeatureLayer",        parameterType="Required",        direction="Input")        param1 = arcpy.Parameter(        displayName="Provider Locations",        name="provider",        datatype="GPFeatureLayer",        parameterType="Required",        direction="Input")        param2 = arcpy.Parameter(        displayName="RSA",        name="rsa",        datatype="GPFeatureLayer",        parameterType="Required",        direction="Input")                 params = [param0, param1, param2]                return params    def isLicensed(self):        """Set whether tool is licensed to execute."""        return True    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""        return    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter.  This method is called after internal validation."""        return    def execute(self, parameters, messages):        """The source code of the tool."""        pop_cen = parameters[0].valueAsText         providers = parameters[1].valueAsText        rsa= parameters[2].valueAsText        #clusterid, area for RSA layer        field_names = [f.name for f in arcpy.ListFields(rsa)]        fields = []        for name in field_names:            if "clusterid" in name or 'hsanum' in name:                fields.append(name)            if "shape_area" in name.lower():                fields.append(name)        #clusterid for POP_CENTROID layer        field_names = [f.name for f in arcpy.ListFields(pop_cen)]        for name in field_names:            if "clusterid" in name or 'hsanum' in name:                clu_pop_cen = name                break        arcpy.AddMessage(clu_pop_cen)                        #arcpy.AddMessage("Fields selected: {}.".format(fields))                if len(fields) != 2:            arcpy.AddMessage("There are some errors with the selected Fields")            return        if '\\' in providers:            ptype = providers.split('\\')[-1].split('_')[0].lower()        else:            ptype = str(providers.split('_')[0]).lower()        arcpy.AddMessage(ptype)        time = ptype + '_time'        dis = ptype + '_distance'        arcpy.AddField_management(rsa, time , "DOUBLE")        arcpy.AddField_management(rsa, dis , "DOUBLE")        fields.append(time)        fields.append(dis)        timeidx = fields.index(time)        disidx = fields.index(dis)        colname = ""                with arcpy.da.UpdateCursor(rsa, fields) as cursor:            for row in cursor:                #get the current cluster id                clusterid = row[0]                if clusterid is None:                    continue                arcpy.AddMessage('Cluster ID: {0}'.format(clusterid))                                #select the corresponding rsa                #pay attention to the quotes format                expression1 = '"{0}" = {1}'.format(fields[0],clusterid)                expression2 = '"{0}" = {1}'.format(clu_pop_cen,clusterid)                                arcpy.AddMessage(expression1)                arcpy.AddMessage(expression2)                arcpy.management.SelectLayerByAttribute(rsa, "NEW_SELECTION", expression1)                arcpy.management.SelectLayerByAttribute(pop_cen, "NEW_SELECTION", expression2)                area = row[1]                area_t = [400000000, 2400000000, 4500000000]                search_t = [5, 15, 70]                if area <= area_t[0]:                    search_d = search_t[0]                elif area <= area_t[1]:                    search_d = search_t[1]                elif area <= area_t[2]:                    search_d = 40                else:                    search_d = search_t[2]                                #create a buffer around the selected rsa                #buffer = "buffer_" + str(clusterid)                #arcpy.analysis.Buffer(rsa, buffer, "10 Kilometers", "OUTSIDE_ONLY")                #arcpy.management.SelectLayerByLocation(providers,"COMPLETELY_WITHIN", buffer)                num = 0                while True:                                        result = [-999]                    search_exp = str(search_d) + " Kilometers"                    #if result[0] >= 0:                        #arcpy.management.SelectLayerByLocation(providers,"CLEAR_SELECTION")                    #select providers within certain distance                    arcpy.AddMessage(search_exp)                    arcpy.management.SelectLayerByLocation(providers,"WITHIN_A_DISTANCE", pop_cen, search_exp, selection_type = "NEW_SELECTION")                    #deselect providers within rsa                    arcpy.management.SelectLayerByLocation(providers,"COMPLETELY_WITHIN", rsa, selection_type = "REMOVE_FROM_SELECTION")                    result = arcpy.GetCount_management(providers)                    arcpy.AddMessage('the area: {0}; the search radius: {1}; number of selected providers: {2}'.format(area, search_d, result[0]))                    num += 1                    if num >= 20 and int(result[0]) > 0 and int(result[0]) <= 10:                        break                    if int(result[0]) <= 10:                        search_d += search_d/5                        arcpy.AddMessage('providers too few, search with increased distance.')                    elif int(result[0]) > 50:                        search_d -= search_d/5                        arcpy.AddMessage('providers too many, search with decreased distance.')                    else:                        break                                #calculate time                outfeature_time = arcpy.env.workspace + '\\' + "time_for_cluster{}".format(clusterid)                arcpy.ba.FindNearbyLocations(pop_cen,clu_pop_cen,providers,outfeature_time,distance_type = "Driving Time",units = "MINUTES",number_limit = 1)                NAMES = [a.name for a in arcpy.ListFields(outfeature_time)]                if colname=="":                    for colname in NAMES:                        if "distance".upper() in colname:                            break                with arcpy.da.SearchCursor(outfeature_time,[colname]) as cursor2:                    for row2 in cursor2:                        row[timeidx] = row2[0]                #calculate distance                outfeature_dis = arcpy.env.workspace + '\\' + "dis_for_cluster{}".format(clusterid)                arcpy.ba.FindNearbyLocations(pop_cen,clu_pop_cen,providers,outfeature_dis,distance_type = "Driving Distance",units = "MILES",number_limit = 1)                with arcpy.da.SearchCursor(outfeature_dis,[colname]) as cursor3:                    for row3 in cursor3:                        row[disidx] = row3[0]                arcpy.AddMessage(row3)                cursor.updateRow(row)        return