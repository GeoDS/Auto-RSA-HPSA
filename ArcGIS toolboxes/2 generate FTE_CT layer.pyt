# -*- coding: utf-8 -*-import arcpyimport matharcpy.env.Overwrite = Trueclass Toolbox(object):    def __init__(self):        """Define the toolbox (the name of the toolbox is the name of the        .pyt file)."""        self.label = "FTE at CT level"        self.alias = "toolbox"        # List of tool classes associated with this toolbox        self.tools = [Tool]class Tool(object):    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "FTE at CT level"        self.description = ""        self.canRunInBackground = False    def getParameterInfo(self):        """Define parameter definitions"""        param0 = arcpy.Parameter(        displayName="Census Tract",        name="ct_in",        datatype="GPFeatureLayer",        parameterType="Required",        direction="Input")        #second parameter        param1 = arcpy.Parameter(        displayName="demo table",        name="demo",        datatype="DETable",        parameterType="Required",        direction="Input")        param2 = arcpy.Parameter(        displayName="Primary Care Providers",        name="primary",        datatype="GPFeatureLayer",        parameterType="Required",        direction="Input")        param3 = arcpy.Parameter(        displayName="Dental Care Providers",        name="dental",        datatype="GPFeatureLayer",        parameterType="Required",        direction="Input")        param4 = arcpy.Parameter(        displayName="Mental Care Providers",        name="mental",        datatype="GPFeatureLayer",        parameterType="Required",        direction="Input")                param5 = arcpy.Parameter(        displayName="Output name",        name="output ct",        datatype="GPFeatureLayer",        parameterType="Required",        direction="Output")                params = [param0, param1, param2, param3, param4, param5]        return params    def isLicensed(self):        """Set whether tool is licensed to execute."""        return True    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""        return    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter.  This method is called after internal validation."""        return    def execute(self, parameters, messages):        """The source code of the tool."""        ct_in = parameters[0].valueAsText #shapefile \census\WI_ct        demo = parameters[1].valueAsText        primary = parameters[2].valueAsText         dental = parameters[3].valueAsText        mental = parameters[4].valueAsText         outfeature = parameters[5].valueAsText        sr = arcpy.SpatialReference("USA Contiguous Albers Equal Area Conic")        arcpy.management.Project(ct_in, 'ct_projected', sr)        ct_proj = 'ct_projected'        arcpy.AddField_management(ct_proj, "ct_num" , "Double")        expression = "int(!GEOID!)"                      arcpy.CalculateField_management(ct_proj, "ct_num", expression, "PYTHON3")        joined_ct = arcpy.management.AddJoin(ct_proj, "ct_num", demo, "ct")        #find the correct name for all fields        field_names = [f.name for f in arcpy.ListFields(joined_ct)]        field_names_str = ' '.join(field_names)        arcpy.AddMessage("Field names: {}.".format(field_names_str))        def add_underscore(field):            return field.replace('.', '_')                    for name in field_names:            if 'pop' in name and 'lwinc' not in name:                pop = name                #pop = add_underscore(pop)                break        #remove the CTs with 0 population        exp = "{0} > 0".format(pop)        arcpy.AddMessage(exp)        arcpy.SelectLayerByAttribute_management(joined_ct, 'NEW_SELECTION', exp)                #add FTE to each ct        #create a field mapping #reference:https://pro.arcgis.com/en/pro-app/latest/tool-reference/analysis/spatial-join.htm         fieldmappings = arcpy.FieldMappings()        fieldmappings.addTable(joined_ct)        fieldmappings.addTable(primary)                FteFieldIndex = fieldmappings.findFieldMapIndex("FTE")        fieldmap = fieldmappings.getFieldMap(FteFieldIndex)        field = fieldmap.outputField        field.name = "pc_fte"        field.aliasName = "pc_fte"        fieldmap.outputField = field        fieldmap.mergeRule = "sum"        fieldmappings.replaceFieldMap(FteFieldIndex, fieldmap)        FteFieldIndex2 = fieldmappings.findFieldMapIndex("FTE_lwinc")        fieldmap = fieldmappings.getFieldMap(FteFieldIndex2)        field = fieldmap.outputField        field.name = "pc_lwinc"        field.aliasName = "pc_lwinc"        fieldmap.outputField = field        fieldmap.mergeRule = "sum"        fieldmappings.replaceFieldMap(FteFieldIndex2, fieldmap)        FieldIndex3 = fieldmappings.findFieldMapIndex("Annual_Medicaid_Claims")        fieldmap3 = fieldmappings.getFieldMap(FieldIndex3)        field3 = fieldmap3.outputField        field3.name = "pc_claims"        field3.aliasName = "pc_claims"        fieldmap3.outputField = field3        fieldmap3.mergeRule = "sum"        fieldmappings.replaceFieldMap(FieldIndex3, fieldmap3)                        #delete unnecessary field        field_names = [f.name for f in arcpy.ListFields(primary)]        for name in field_names:            try:                x = fieldmappings.findFieldMapIndex(name)                fieldmappings.removeFieldMap(x)            except:                arcpy.AddMessage("name: {}".format(name))                continue        intermediate = 'ct_intermeidate'        arcpy.SpatialJoin_analysis(joined_ct, primary, intermediate, "JOIN_ONE_TO_ONE", \                                   field_mapping = fieldmappings, match_option = "COMPLETELY_CONTAINS")                fieldmappings = arcpy.FieldMappings()        fieldmappings.addTable(intermediate)        fieldmappings.addTable(mental)                FteFieldIndex2 = fieldmappings.findFieldMapIndex("psy_FTE")        fieldmap = fieldmappings.getFieldMap(FteFieldIndex2)        field = fieldmap.outputField        field.name = "psy_fte"        field.aliasName = "psy_fte"        fieldmap.outputField = field        fieldmap.mergeRule = "sum"        fieldmappings.replaceFieldMap(FteFieldIndex2, fieldmap)                #delete unnecessary field        field_names = [f.name for f in arcpy.ListFields(mental)]        for name in field_names:            arcpy.AddMessage(name)            if 'psy' in name:                continue            try:                x = fieldmappings.findFieldMapIndex(name)                fieldmappings.removeFieldMap(x)            except:                arcpy.AddMessage("name: {}".format(name))                continue        intermediate2 = 'ct_intermeidate2'        arcpy.SpatialJoin_analysis(intermediate, mental, intermediate2, "JOIN_ONE_TO_ONE", \                                   field_mapping = fieldmappings, match_option = "COMPLETELY_CONTAINS")                fieldmappings = arcpy.FieldMappings()        fieldmappings.addTable(intermediate2)        fieldmappings.addTable(dental)                FteFieldIndex3 = fieldmappings.findFieldMapIndex("FTE_lwinc")        fieldmap = fieldmappings.getFieldMap(FteFieldIndex3)        field = fieldmap.outputField        field.name = "dh_lwinc"        field.aliasName = "dh_lwinc"        fieldmap.outputField = field        fieldmap.mergeRule = "sum"        fieldmappings.replaceFieldMap(FteFieldIndex3, fieldmap)                #delete unnecessary field        field_names = [f.name for f in arcpy.ListFields(dental)]        for name in field_names:            arcpy.AddMessage(name)            if 'FTE_lwinc' in name:                continue            try:                x = fieldmappings.findFieldMapIndex(name)                fieldmappings.removeFieldMap(x)            except:                arcpy.AddMessage("name: {}".format(name))                continue        arcpy.SpatialJoin_analysis(intermediate2, dental, outfeature, "JOIN_ONE_TO_ONE", \                                   field_mapping = fieldmappings, match_option = "COMPLETELY_CONTAINS")        arcpy.Delete_management(intermediate)        arcpy.Delete_management(intermediate2)        def add_underscore(field):            return field.replace(' ', '_')                field_names = [f.name for f in arcpy.ListFields(outfeature)]        for name in field_names:            if 'pop' in name and 'lwinc' not in name:                pop = name                pop = add_underscore(pop)                arcpy.AddMessage(name)            if 'fte' in name and 'lw' not in name:                fte = name                fte = add_underscore(fte)                arcpy.AddMessage(name)##        #add pop/fte field for the input cluster table##        arcpy.AddField_management(outfeature, "pop_fte" , "Float")####        expression1 = "ratio(!" + pop + "!,!" + fte + "!)"##        codeblock1 = """def ratio(pop, fte):##            if fte == 0:##                return math.inf##            else:##                value = pop/fte##                return value """##        arcpy.CalculateField_management(outfeature, "pop_fte", expression1, "PYTHON3", codeblock1)                return