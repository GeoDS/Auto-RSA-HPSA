# -*- coding: utf-8 -*-import arcpyarcpy.env.overwriteOutput = Trueimport csvimport pandas as pdimport osimport mathclass Toolbox(object):    def __init__(self):        """Define the toolbox (the name of the toolbox is the name of the        .pyt file)."""        self.label = "Coutiougs Area Check"        self.alias = "toolbox"        # List of tool classes associated with this toolbox        self.tools = [Tool1, Tool2]class Tool1(object):    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "Find CA"        self.description = ""        self.canRunInBackground = False    def getParameterInfo(self):        """Define parameter definitions"""        param0 = arcpy.Parameter(        displayName="Population Centroid",        name="pop_cen",        datatype="GPFeatureLayer",        parameterType="Required",        direction="Input")        param1 = arcpy.Parameter(        displayName="Provider Locations",        name="provider",        datatype="GPFeatureLayer",        parameterType="Required",        direction="Input")        param2 = arcpy.Parameter(        displayName="RSA",        name="rsa",        datatype="GPFeatureLayer",        parameterType="Required",        direction="Input")                 param3 = arcpy.Parameter(        displayName="output CA table",        name="ca",        datatype="DETable",        parameterType="Required",        direction="Output")        param4 = arcpy.Parameter(        displayName="output neighbor provider rsa table",        name="providerRSA",        datatype="DETable",        parameterType="Required",        direction="Output")        param5 = arcpy.Parameter(        displayName="travel polygons name",        name="output_polygons",        datatype="GPString",        parameterType="Required",        direction="Output")        param6 = arcpy.Parameter(        displayName="calculate travel polygons?",        name="calpoly",        datatype="GPBoolean",        parameterType="Optional",        direction="Input")        param6.value = 'true'        params = [param0, param1, param2, param3, param4, param5, param6]                return params    def isLicensed(self):        """Set whether tool is licensed to execute."""        return True    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""        return    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter.  This method is called after internal validation."""        return    def execute(self, parameters, messages):        """The source code of the tool."""        pop_cen = parameters[0].valueAsText         provider= parameters[1].valueAsText        rsa_shp = parameters[2].valueAsText        output = parameters[3].valueAsText        nbhRSA = parameters[4].valueAsText        output_poly = parameters[5].valueAsText        calpoly = parameters[6].valueAsText        provider_name = provider.lower()        if 'primary' in provider_name:            time = 30        elif 'mental' in provider_name:            time = 40        elif 'dental' in provider_name:            time = 40        arcpy.AddMessage("The travel time used is {0} mintues.".format(time))                    #clusterid, area for RSA layer        field_names = [f.name for f in arcpy.ListFields(rsa_shp)]                for name in field_names:            if "clusterid" in name or 'hsanum' in name:                rsa_clu = name                break        #clusterid for POP_CENTROID layer        fields = []        field_names = [f.name for f in arcpy.ListFields(pop_cen)]        for name in field_names:            if "clusterid" in name or 'hsanum' in name:                pop_clu = name                fields.append(name)                break        arcpy.AddMessage([rsa_clu, pop_clu])                f1 = open(output, "w")        header = ["rsa", "ca", "\n"]        f1.write(",".join(header))        f2 = open(nbhRSA, "w")        header = ["rsa", "ca_with_providers", "\n"]        f2.write(",".join(header))        ###generate the travel polygon        #output_poly = "D:\\Box Sync\\Spring 2021\\DHS Project\\DHS_safegraph\\scratch.gdb\\" + output_poly        arcpy.AddMessage(calpoly)        if calpoly == 'true':            arcpy.ba.GenerateDriveTimeTradeArea(pop_cen,output_poly,"Driving Time", time, "MINUTES", pop_clu,\                                                    "OVERLAP", "KEEP_OVERLAP","AWAY_FROM_STORES")              arcpy.AddMessage("start generating the two files")        with arcpy.da.UpdateCursor(pop_cen, fields) as cursor:            for row in cursor:                #get the current cluster id                clusterid = row[0]                if clusterid is None:                    continue                arcpy.AddMessage('Cluster ID: {0}'.format(clusterid))                                #select the corresponding rsa                #pay attention to the quotes format                expression1 = '"{0}" = {1}'.format(pop_clu,clusterid)                #arcpy.management.SelectLayerByAttribute(pop_cen, "NEW_SELECTION", expression1)                travel_poly, count = arcpy.management.SelectLayerByAttribute(output_poly, "NEW_SELECTION", expression1)                #select the rsa that intersects the travel polygon                arcpy.management.SelectLayerByLocation(rsa_shp,"INTERSECT",travel_poly, selection_type = "NEW_SELECTION")                with arcpy.da.SearchCursor(rsa_shp, fields) as cur:                    for row in cur:                        if str(row[0]) == str(clusterid):                            continue                        pair = [str(clusterid), str(row[0]), "\n"]                        f1.write(",".join(pair))                #first select the current rsa                expression2 = '"{0}" = {1}'.format(rsa_clu,clusterid)                arcpy.management.SelectLayerByAttribute(rsa_shp,"NEW_SELECTION", expression2)                                #select the providers that are within the travel polygon                arcpy.management.SelectLayerByLocation(provider,"WITHIN",travel_poly, selection_type = "NEW_SELECTION")                #remove the ones inside the current rsa                arcpy.management.SelectLayerByLocation(provider,"WITHIN", rsa_shp, selection_type = "REMOVE_FROM_SELECTION")                #then, reselect the rsas that contains those providers                arcpy.management.SelectLayerByLocation(rsa_shp,"CONTAINS",provider, selection_type = "NEW_SELECTION")                with arcpy.da.SearchCursor(rsa_shp, fields) as cur:                    for row in cur:                        pair = [str(clusterid), str(row[0]), "\n"]                        f2.write(",".join(pair))        f1.close()        f2.close()        class Tool2(object):    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "Run CA checks"        self.description = ""        self.canRunInBackground = False    def getParameterInfo(self):        """Define parameter definitions"""        param0 = arcpy.Parameter(        displayName="RSA",        name="rsa",        datatype="GPFeatureLayer",        parameterType="Required",        direction="Input")                 param1 = arcpy.Parameter(        displayName="CA table",        name="ca",        datatype="DETable",        parameterType="Required",        direction="Input")        param2 = arcpy.Parameter(        displayName="neighbor provider rsa table",        name="providerRSA",        datatype="DETable",        parameterType="Required",        direction="Input")        param3 = arcpy.Parameter(        displayName="RSA output",        name="rsa output",        datatype="GPFeatureLayer",        parameterType="Required",        direction="Output")        param4 = arcpy.Parameter(        displayName="CA check result table",        name="ca output",        datatype="DETable",        parameterType="Required",        direction="Output")        param5 = arcpy.Parameter(        displayName="HPSA type",        name="HPSA type",        datatype="GPString",        parameterType="Required",        direction="Input")                params = [param0, param1, param2, param3, param4, param5]                return params    def isLicensed(self):        """Set whether tool is licensed to execute."""        return True    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""        return    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter.  This method is called after internal validation."""        return    def execute(self, parameters, messages):        """The source code of the tool."""        rsa_shp = parameters[0].valueAsText        ca_input = parameters[1].valueAsText        nbhRSA = parameters[2].valueAsText        outRSA = parameters[3].valueAsText        ca_result = parameters[4].valueAsText        hpsa_type = parameters[5].valueAsText        #clusterid, area for RSA layer        field_names = [f.name for f in arcpy.ListFields(rsa_shp)]                for name in field_names:            if "clusterid" in name or 'hsanum' in name:                rsa_clu = name                break        arcpy.AddMessage("start the CA checks")        rsa_output = 'rsa.csv'        path  = os.path.dirname(arcpy.env.workspace) + "\\"        try:            os.remove(path + rsa_output)            print("remove existing rsa.csv")        except:            print("no rsa.csv right now")                    arcpy.SelectLayerByAttribute_management(rsa_shp, "CLEAR_SELECTION")        arcpy.TableToTable_conversion(rsa_shp, os.path.dirname(arcpy.env.workspace), rsa_output)        rsa = pd.read_csv(rsa_output)        rsa = rsa.drop(columns = {'OID_'})                ca = pd.read_csv(ca_input)        if 'Unnamed: 2' in ca.columns:            ca = ca.drop(columns = {'Unnamed: 2'})                provider_df = pd.read_csv(nbhRSA)        if 'Unnamed: 2' in ca.columns:            provider_df = provider.drop(columns = {'Unnamed: 2'})        for name in rsa.columns:            if 'poverty' in name and 'score' not in name:                poverty = name            if 'pop' in name and 'lwinc' not in name and 'constraint' not in name and 'water' not in name:                pop = name            if 'clusterid' in name or 'hsanum' in name:                clusterid = name            if 'pop' in name and 'lwinc' in name:                pop_lwinc = name            if 'pc_fte' in name and 'lw' not in name:                sum_fte = name            if 'pc' in name and 'lw' in name:                fte_lwinc = name            if 'claims' in name:                medicaid = name            if 'black' in name:                black = name            if 'native' in name:                native = name            if 'asian' in name:                asian = name            if 'white_noh' in name:                white_noh = name            if 'hispanic' in name:                hispanic = name            if 'hawaiian' in name:                hawaiian = name            if 'psy_fte' in name:                psy_fte = name            if 'dh_lwinc' in name:                dh_fte = name        rsa_name = hpsa_type.lower()                if 'primary' in rsa_name:            pop_fte_con = 2000            if 'lw' in rsa_name:                fte = fte_lwinc                pop = pop_lwinc            else:                fte = sum_fte                    elif 'dental' in rsa_name:            pop_fte_con = 3000            if 'lw' in rsa_name:                fte = dh_fte                pop = pop_lwinc        elif 'mental' in rsa_name:            pop_fte_con = 20000            fte = psy_fte        arcpy.AddMessage("The rsa name is {0}, the fte used is {1}, the population used is {2}".format(rsa_name, fte, pop))            def over_utilized(ca, rsa, pop_fte_con):            ca['over_ut'] = False            ca = pd.merge(ca, rsa[[clusterid, pop, fte]], left_on = ['ca'], right_on = [clusterid])            ca['pop_fte'] = ca[pop]/ca[fte]            ca.at[ca.pop_fte > pop_fte_con, 'over_ut'] = True            ca.at[ca.pop_fte == math.inf, 'over_ut'] = True            return ca.drop(columns = {clusterid, pop, fte})        ca = over_utilized(ca, rsa, pop_fte_con)        arcpy.AddMessage('finish over utilized')        def demo_cal(ca, rsa):            if ca == rsa:                return False            if rsa < ca:                return demo_compare(rsa, ca)            else:                return demo_compare(ca, rsa)        def demo_compare(base, comp):            if base < 0.15:                base += 0.15                if comp >= base:                    return True                elif comp < base:                    return False            elif base >= 0.15:                base *= 2                if comp >= base:                    return True                elif comp < base:                    return False                    def demo_dis(ca, rsa):            ca['demo_dis'] = False            columns = [poverty, pop_lwinc, black, native, asian, white_noh, hispanic, hawaiian]            #arcpy.AddMessage(columns)            for i, row in ca.iterrows():                rsa_id = row['rsa']                ca_id = row['ca']                #perform the check                #arcpy.AddMessage(rsa)                #arcpy.AddMessage(rsa[rsa[clusterid] == rsa_id])                for col in columns:                                      rsa_perc = float(rsa[rsa[clusterid] == rsa_id][col]/rsa[rsa[clusterid] == rsa_id][pop])                    ca_perc = float(rsa[rsa[clusterid] == ca_id][col]/rsa[rsa[clusterid] == ca_id][pop])                    if demo_cal(ca_perc, rsa_perc) == True:                        ca.at[i, 'demo_dis'] = True                        break            return ca        ca = demo_dis(ca, rsa)        arcpy.AddMessage('finish demo check')        def distant_provider(ca, rsa, provider):            ca['dist_pvd'] = False            ca = ca.merge(provider, left_on = ['rsa','ca'], right_on = ['rsa','ca_with_providers'], how = 'left')            ca.at[ca['ca_with_providers'].isna(), 'dist_pvd'] = True            return ca.drop(columns = ['ca_with_providers'])        ca = distant_provider(ca, rsa, provider_df)        arcpy.AddMessage('finish distant provider')        def lack_eco(ca, rsa):            ca['lack_eco'] = False                cols = ca.columns            ca = pd.merge(ca, rsa[[clusterid, pop, poverty]], left_on = ['rsa'], right_on = [clusterid])            ca['rsa_povperc'] = ca[poverty]/ca[pop]            ca = pd.merge(ca, rsa[[clusterid, medicaid]], left_on = ['ca'], right_on = [clusterid])            ca.at[(ca.rsa_povperc > 0.2) &(ca[medicaid] == 0), 'lack_eco'] = True            return ca[cols]        ca = lack_eco(ca, rsa)        arcpy.AddMessage('finish lack of economic access')        ca['CA check'] = ''        ca['CA check'] = (ca['over_ut'] == True) | (ca['lack_eco'] == True)|(ca['demo_dis'] == True)|(ca['dist_pvd'] == True)                ca['CA_constraint'] = 0        ca.at[ca['CA check'] == True, 'CA_constraint'] = 1                #output the 5 CA check result        ca.to_csv(ca_result, index = False)                result = ca[['rsa','ca','CA_constraint']].groupby(['rsa']).agg({'CA_constraint':'min'}).reset_index()        rsa_ca_result = 'CA_result_temp.csv'        result[['rsa', 'CA_constraint']].to_csv(path + rsa_ca_result, index = False)        rsa_joined = arcpy.AddJoin_management(rsa_shp, rsa_clu, rsa_ca_result, "rsa")        arcpy.management.CopyFeatures(rsa_joined, outRSA)        #fix the problem that some RSAs are not in the ca table        field_names = [f.name for f in arcpy.ListFields(outRSA)]        field_names_str = ' '.join(field_names)        arcpy.AddMessage("Field names: {}.".format(field_names_str))        def add_underscore(field):            return field.replace(' ', '_')        for name in field_names:            if 'clusterid' in name or 'hsanum' in name:                clusterid = name                clusterid = add_underscore(clusterid)            if 'CA_constraint' in name:                ca_constraint = name            if 'csv_rsa' in name:                rsa_id = name        expression2 = "fill_ca_na(!" + rsa_id + "!,!" + ca_constraint + "!)"                codeblock2 = """def fill_ca_na(rsa, ca):            if rsa is None:                return 1            else:                return ca                """                          arcpy.CalculateField_management(outRSA, ca_constraint, expression2, "PYTHON3", codeblock2)        expression1 = "fill_na(!" + rsa_id + "!,!" + clusterid + "!)"                codeblock1 = """def fill_na(rsa, clusterid):            if rsa is None:                return clusterid            else:                return rsa                """                          arcpy.CalculateField_management(outRSA, rsa_id, expression1, "PYTHON3", codeblock1)                arcpy.AddMessage("done")                        return